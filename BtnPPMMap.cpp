#include "BtnPPMMap.h"

/**
  Button to PPM Mapping - Maps the joystick buttons and actions to different PPM values
  @Author github.com/lexfp
*/
BtnPPMMap::BtnPPMMap()
{
  NUM_CHANNELS[CAR_DEFAULT] = 6;
  PPM_THROTTLE_NEUTRAL[CAR_DEFAULT] = 1500;
  WHEEL_REVERSE_STEERING[CAR_DEFAULT] = false;
  WHEEL_LEFT_TURN_LIMIT[CAR_DEFAULT] = PPM_MIN_VALUE;
  WHEEL_CENTER[CAR_DEFAULT] = PPM_CENTER_VALUE;
  WHEEL_RIGHT_TURN_LIMIT[CAR_DEFAULT] = PPM_MAX_VALUE;
  FIRST_GEAR_FORWARD_LIMIT_PERCENT[CAR_DEFAULT] = 10;
  SECOND_GEAR_FORWARD_LIMIT_PERCENT[CAR_DEFAULT] = 30;
  THIRD_GEAR_FORWARD_LIMIT_PERCENT[CAR_DEFAULT] = 50;
  FOURTH_GEAR_FORWARD_LIMIT_PERCENT[CAR_DEFAULT] = 100;
  FIRST_GEAR_REVERSE_LIMIT_PERCENT[CAR_DEFAULT] = 30;
  SECOND_GEAR_REVERSE_LIMIT_PERCENT[CAR_DEFAULT] = 50;
  THIRD_GEAR_REVERSE_LIMIT_PERCENT[CAR_DEFAULT] = 70;
  FOURTH_GEAR_REVERSE_LIMIT_PERCENT[CAR_DEFAULT] = 100;

  NUM_CHANNELS[CAR_MINI_Q5] = 6;
  PPM_THROTTLE_NEUTRAL[CAR_MINI_Q5] = 1451;
  WHEEL_REVERSE_STEERING[CAR_MINI_Q5] = true;
  WHEEL_LEFT_TURN_LIMIT[CAR_MINI_Q5] = PPM_MIN_VALUE;
  WHEEL_CENTER[CAR_MINI_Q5] = 1450;
  WHEEL_RIGHT_TURN_LIMIT[CAR_MINI_Q5] = PPM_MAX_VALUE;
  FIRST_GEAR_FORWARD_LIMIT_PERCENT[CAR_MINI_Q5] = 15;
  SECOND_GEAR_FORWARD_LIMIT_PERCENT[CAR_MINI_Q5] = 50;
  THIRD_GEAR_FORWARD_LIMIT_PERCENT[CAR_MINI_Q5] = 70;
  FOURTH_GEAR_FORWARD_LIMIT_PERCENT[CAR_MINI_Q5] = 100;
  FIRST_GEAR_REVERSE_LIMIT_PERCENT[CAR_MINI_Q5] = 30;
  SECOND_GEAR_REVERSE_LIMIT_PERCENT[CAR_MINI_Q5] = 50;
  THIRD_GEAR_REVERSE_LIMIT_PERCENT[CAR_MINI_Q5] = 70;
  FOURTH_GEAR_REVERSE_LIMIT_PERCENT[CAR_MINI_Q5] = 100;
  
  NUM_CHANNELS[CAR_MICRO_TRUGGY] = 6;
  PPM_THROTTLE_NEUTRAL[CAR_MICRO_TRUGGY] = 1470;
  WHEEL_REVERSE_STEERING[CAR_MICRO_TRUGGY] = false;
  WHEEL_LEFT_TURN_LIMIT[CAR_MICRO_TRUGGY] = 1080;
  WHEEL_CENTER[CAR_MICRO_TRUGGY] = PPM_CENTER_VALUE;
  WHEEL_RIGHT_TURN_LIMIT[CAR_MICRO_TRUGGY] = 1920;
  FIRST_GEAR_FORWARD_LIMIT_PERCENT[CAR_MICRO_TRUGGY] = 10;
  SECOND_GEAR_FORWARD_LIMIT_PERCENT[CAR_MICRO_TRUGGY] = 30;
  THIRD_GEAR_FORWARD_LIMIT_PERCENT[CAR_MICRO_TRUGGY] = 50;
  FOURTH_GEAR_FORWARD_LIMIT_PERCENT[CAR_MICRO_TRUGGY] = 100;
  FIRST_GEAR_REVERSE_LIMIT_PERCENT[CAR_MICRO_TRUGGY] = 30;
  SECOND_GEAR_REVERSE_LIMIT_PERCENT[CAR_MICRO_TRUGGY] = 50;
  THIRD_GEAR_REVERSE_LIMIT_PERCENT[CAR_MICRO_TRUGGY] = 70;
  FOURTH_GEAR_REVERSE_LIMIT_PERCENT[CAR_MICRO_TRUGGY] = 100;
  
  NUM_CHANNELS[CAR_MICRO_T] = 6;
  PPM_THROTTLE_NEUTRAL[CAR_MICRO_T] = 1450;
  WHEEL_REVERSE_STEERING[CAR_MICRO_T] = false;
  WHEEL_LEFT_TURN_LIMIT[CAR_MICRO_T] = 1100;
  WHEEL_CENTER[CAR_MICRO_T] = 1435;
  WHEEL_RIGHT_TURN_LIMIT[CAR_MICRO_T] = 1800;
  FIRST_GEAR_FORWARD_LIMIT_PERCENT[CAR_MICRO_T] = 18;
  SECOND_GEAR_FORWARD_LIMIT_PERCENT[CAR_MICRO_T] = 40;
  THIRD_GEAR_FORWARD_LIMIT_PERCENT[CAR_MICRO_T] = 75;
  FOURTH_GEAR_FORWARD_LIMIT_PERCENT[CAR_MICRO_T] = 100;
  FIRST_GEAR_REVERSE_LIMIT_PERCENT[CAR_MICRO_T] = 30;
  SECOND_GEAR_REVERSE_LIMIT_PERCENT[CAR_MICRO_T] = 40;
  THIRD_GEAR_REVERSE_LIMIT_PERCENT[CAR_MICRO_T] = 70;
  FOURTH_GEAR_REVERSE_LIMIT_PERCENT[CAR_MICRO_T] = 100;
  
  changeCar(CURRENT_CAR);
  currentGear = 0;
  lastShiftUpMillis = millis();
  lastShiftDownMillis = millis();
  channel[CH_THROTTLE] = PPM_THROTTLE_NEUTRAL[CURRENT_CAR];
  channel[CH_STEERING] = WHEEL_CENTER[CURRENT_CAR];
  channel[CH_SHIFTER] = GEAR_FORWARD_LIMIT[CURRENT_CAR][0];
  channel[CH_4] = PPM_FAIL_SAFE_VALUE;
  channel[CH_5] = PPM_FAIL_SAFE_VALUE;
  channel[CH_6] = PPM_FAIL_SAFE_VALUE;
  channel[CH_7] = PPM_FAIL_SAFE_VALUE;
  channel[CH_8] = PPM_FAIL_SAFE_VALUE;
}

void BtnPPMMap::changeCar(int car) {
  CURRENT_CAR = car;
  
  int PPM_THROTTLE_FORWARD_RANGE = PPM_MAX_VALUE - PPM_THROTTLE_NEUTRAL[car];
  int PPM_THROTTLE_REVERSE_RANGE = PPM_THROTTLE_NEUTRAL[car] - PPM_MIN_VALUE;
  int FIRST_GEAR_FORWARD_LIMIT = ((FIRST_GEAR_FORWARD_LIMIT_PERCENT[car] / 100.0) * PPM_THROTTLE_FORWARD_RANGE) + PPM_THROTTLE_NEUTRAL[car];
  int SECOND_GEAR_FORWARD_LIMIT = ((SECOND_GEAR_FORWARD_LIMIT_PERCENT[car] / 100.0) * PPM_THROTTLE_FORWARD_RANGE) + PPM_THROTTLE_NEUTRAL[car];
  int THIRD_GEAR_FORWARD_LIMIT = ((THIRD_GEAR_FORWARD_LIMIT_PERCENT[car] / 100.0) * PPM_THROTTLE_FORWARD_RANGE) + PPM_THROTTLE_NEUTRAL[car];
  int FOURTH_GEAR_FORWARD_LIMIT = ((FOURTH_GEAR_FORWARD_LIMIT_PERCENT[car] / 100.0) * PPM_THROTTLE_FORWARD_RANGE) + PPM_THROTTLE_NEUTRAL[car];
  int FIRST_GEAR_REVERSE_LIMIT = (PPM_THROTTLE_NEUTRAL[car] - ((FIRST_GEAR_REVERSE_LIMIT_PERCENT[car] / 100.0) * PPM_THROTTLE_REVERSE_RANGE));
  int SECOND_GEAR_REVERSE_LIMIT = (PPM_THROTTLE_NEUTRAL[car] - ((SECOND_GEAR_REVERSE_LIMIT_PERCENT[car] / 100.0) * PPM_THROTTLE_REVERSE_RANGE));
  int THIRD_GEAR_REVERSE_LIMIT = (PPM_THROTTLE_NEUTRAL[car] - ((THIRD_GEAR_REVERSE_LIMIT_PERCENT[car] / 100.0) * PPM_THROTTLE_REVERSE_RANGE));
  int FOURTH_GEAR_REVERSE_LIMIT = (PPM_THROTTLE_NEUTRAL[car] - ((FOURTH_GEAR_REVERSE_LIMIT_PERCENT[car] / 100.0) * PPM_THROTTLE_REVERSE_RANGE));
  GEAR_FORWARD_LIMIT[car][0] = FIRST_GEAR_FORWARD_LIMIT;
  GEAR_FORWARD_LIMIT[car][1] = SECOND_GEAR_FORWARD_LIMIT;
  GEAR_FORWARD_LIMIT[car][2] = THIRD_GEAR_FORWARD_LIMIT;
  GEAR_FORWARD_LIMIT[car][3] = FOURTH_GEAR_FORWARD_LIMIT;
  GEAR_REVERSE_LIMIT[car][0] = FIRST_GEAR_REVERSE_LIMIT;
  GEAR_REVERSE_LIMIT[car][1] = SECOND_GEAR_REVERSE_LIMIT;
  GEAR_REVERSE_LIMIT[car][2] = THIRD_GEAR_REVERSE_LIMIT;
  GEAR_REVERSE_LIMIT[car][3] = FOURTH_GEAR_REVERSE_LIMIT;
  
  PPM_THROTTLE_MAX = GEAR_FORWARD_LIMIT[CURRENT_CAR][0];
  PPM_REVERSE_MAX = GEAR_REVERSE_LIMIT[CURRENT_CAR][0];

  debugCurrentCar();
}

int BtnPPMMap::getNumChannels() {
  return NUM_CHANNELS[CURRENT_CAR];
}

int BtnPPMMap::getChannelValue(int c) {
  return channel[c];
}

void BtnPPMMap::mapGas(uint32_t value) {
  if (value < MAX_GAS_INPUT) {
    //stepping on break
    mapBreakValue(value);
  } else if (value < NEUTRAL_GAS_INPUT) {
    //stepping on gas
    mapGasValue(value);
  }

}

void BtnPPMMap::mapShift(long value) {
  //shift up and down for gears
  if (value == SHIFT_UP_INPUT) {
    shiftUp();
  } else if (value == SHIFT_DOWN_INPUT) {
    shiftDown();
  }
}

void BtnPPMMap::mapSteer(long value) {
  if (value < WHEEL_CENTER_INPUT) {
    //turning left
    if (WHEEL_REVERSE_STEERING[CURRENT_CAR]) {
      //reverse steering
      mapChannelValue(true, CH_STEERING, value, WHEEL_MIN_INPUT, WHEEL_CENTER_INPUT, WHEEL_CENTER[CURRENT_CAR], WHEEL_RIGHT_TURN_LIMIT[CURRENT_CAR]);
    } else {
      mapChannelValue(false, CH_STEERING, value, WHEEL_MIN_INPUT, WHEEL_CENTER_INPUT, WHEEL_LEFT_TURN_LIMIT[CURRENT_CAR], WHEEL_CENTER[CURRENT_CAR]);
    }
  } else {
    //turning right
    if (WHEEL_REVERSE_STEERING[CURRENT_CAR]) {
      //reverse steering
      mapChannelValue(true, CH_STEERING, value, WHEEL_CENTER_INPUT, WHEEL_MAX_INPUT, WHEEL_LEFT_TURN_LIMIT[CURRENT_CAR], WHEEL_CENTER[CURRENT_CAR]);
    } else {
      mapChannelValue(false, CH_STEERING, value, WHEEL_CENTER_INPUT, WHEEL_MAX_INPUT, WHEEL_CENTER[CURRENT_CAR], WHEEL_RIGHT_TURN_LIMIT[CURRENT_CAR]);
    }
  }
}

void BtnPPMMap::mapGasValue(uint32_t value) {
  mapChannelValue(true, CH_THROTTLE, value, MAX_GAS_INPUT, NEUTRAL_GAS_INPUT, PPM_THROTTLE_NEUTRAL[CURRENT_CAR], PPM_THROTTLE_MAX);
}

void BtnPPMMap::mapBreakValue(uint32_t value) {
  mapChannelValue(false, CH_THROTTLE, value, MAX_BREAK_INPUT, NEUTRAL_GAS_INPUT, PPM_REVERSE_MAX, PPM_THROTTLE_NEUTRAL[CURRENT_CAR]);
}

void BtnPPMMap::mapChannelValue(boolean invert, int c, uint32_t value, uint32_t minValue, uint32_t maxValue, int ppmMin, int ppmMax) {
  if (invert) {
    channel[c] = mapf(value, minValue, maxValue, ppmMax, ppmMin);
  } else {
    channel[c] = mapf(value, minValue, maxValue, ppmMin, ppmMax);
  }
}

long BtnPPMMap::mapf(float x, float in_min, float in_max, float out_min, float out_max) {
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

void BtnPPMMap::failsafe() {
  //put your own code here for this functionality
  //be sure to set up your FC software to failsafe on this value as well
}

void BtnPPMMap::disArm() {
  //substitute your own disarm code below instead
  channel[CH_THROTTLE] = PPM_THROTTLE_NEUTRAL[CURRENT_CAR];
  channel[CH_STEERING] = PPM_CENTER_VALUE;
}

void BtnPPMMap::shiftUp() {
  if (millis() - lastShiftUpMillis > DELAY_BETWEEN_SHIFT_MILLIS) {
    if (currentGear < NUM_GEARS - 1) {
      currentGear++;
    }
    PPM_THROTTLE_MAX = GEAR_FORWARD_LIMIT[CURRENT_CAR][currentGear];
    PPM_REVERSE_MAX = GEAR_REVERSE_LIMIT[CURRENT_CAR][currentGear];
    lastShiftUpMillis = millis();
  }
}

void BtnPPMMap::shiftDown() {
  if (millis() - lastShiftDownMillis > DELAY_BETWEEN_SHIFT_MILLIS) {
    if (currentGear > 0) {
      currentGear--;
    }
    PPM_THROTTLE_MAX = GEAR_FORWARD_LIMIT[CURRENT_CAR][currentGear];
    PPM_REVERSE_MAX = GEAR_REVERSE_LIMIT[CURRENT_CAR][currentGear];
    lastShiftDownMillis = millis();
  }
}

void BtnPPMMap::debug()
{
  Serial.print("OUT - CC:");
  Serial.print(CURRENT_CAR);
  Serial.print(" T:");
  Serial.print(channel[CH_THROTTLE]);
  Serial.print(" W:");
  Serial.print(channel[CH_STEERING]);
  Serial.print(" FM:");
  Serial.print(PPM_THROTTLE_MAX);
  Serial.print(" RM:");
  Serial.print(PPM_REVERSE_MAX);
  Serial.println("");
}

void BtnPPMMap::debugCurrentCar()
{
  Serial.print("CC:");
  Serial.print(CURRENT_CAR);
  Serial.print(" TN:");
  Serial.print(PPM_THROTTLE_NEUTRAL[CURRENT_CAR]);
  Serial.print(" WR:");
  if (WHEEL_REVERSE_STEERING[CURRENT_CAR]) {
    Serial.print("true");    
  } else {
    Serial.print("false");
  }
  Serial.print(" WC:");
  Serial.print(WHEEL_CENTER[CURRENT_CAR]);
  Serial.print(" WLL:");
  Serial.print(WHEEL_LEFT_TURN_LIMIT[CURRENT_CAR]);
  Serial.print(" WRL:");
  Serial.print(WHEEL_RIGHT_TURN_LIMIT[CURRENT_CAR]);
  Serial.println("");
}
